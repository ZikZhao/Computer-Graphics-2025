#include <chrono>
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <thread>
#include <vector>

#include "raytracer.hpp"
#include "renderer.hpp"
#include "utils.hpp"
#include "video_recorder.hpp"
#include "window.hpp"
#include "world.hpp"

constexpr std::size_t WindowWidth = 640;
constexpr std::size_t WindowHeight = 480;

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <scene1.obj> [<scene2.obj> ...]" << std::endl;
        return EXIT_FAILURE;
    }

    // Load world assets from CLI arguments
    World world = {std::vector<std::string>(argv + 1, argv + argc)};

    // Initialize output window and rendering engines
    Window window(WindowWidth, WindowHeight);
    world.camera_.set_aspect_ratio(static_cast<double>(WindowWidth) / WindowHeight);
    Renderer renderer(world, window);
    VideoRecorder video_recorder(window.get_pixel_buffer(), WindowWidth, WindowHeight);

    std::uint32_t fps = 0;
    auto last_print = std::chrono::steady_clock::now();

    // Centralized input callbacks: movement and UI toggles
    window.register_key(
        {SDL_SCANCODE_W,
         SDL_SCANCODE_S,
         SDL_SCANCODE_A,
         SDL_SCANCODE_D,
         SDL_SCANCODE_SPACE,
         SDL_SCANCODE_C},
        Window::Trigger::ANY_PRESSED_NO_MODIFIER,
        [&](const Window::KeyState& ks, float dt) {
            constexpr FloatType move_step = 3.0f;
            constexpr FloatType video_fixed_dt = 1.0f / 60.0f;  // Fixed step for video recording
            FloatType fwd = (ks[SDL_SCANCODE_W] ? 1.0f : 0.0f) - (ks[SDL_SCANCODE_S] ? 1.0f : 0.0f);
            FloatType right =
                (ks[SDL_SCANCODE_D] ? 1.0f : 0.0f) - (ks[SDL_SCANCODE_A] ? 1.0f : 0.0f);
            FloatType up =
                (ks[SDL_SCANCODE_SPACE] ? 1.0f : 0.0f) - (ks[SDL_SCANCODE_C] ? 1.0f : 0.0f);
            if (fwd != 0.0f || right != 0.0f || up != 0.0f) {
                FloatType effective_dt = video_recorder.is_recording() ? video_fixed_dt : dt;
                world.camera_.move(
                    fwd * move_step, right * move_step, up * move_step, effective_dt
                );
                renderer.reset_accumulation();
            }
        }
    );

    window.register_key(
        {SDL_SCANCODE_Q, SDL_SCANCODE_E},
        Window::Trigger::ANY_PRESSED_NO_MODIFIER,
        [&](const Window::KeyState& ks, float dt) {
            constexpr FloatType roll_speed = 0.5f;
            constexpr FloatType video_fixed_dt = 1.0f / 60.0f;  // Fixed step for video recording
            FloatType r = (ks[SDL_SCANCODE_E] ? 1.0f : 0.0f) - (ks[SDL_SCANCODE_Q] ? 1.0f : 0.0f);
            if (r != 0.0f) {
                FloatType effective_dt = video_recorder.is_recording() ? video_fixed_dt : dt;
                world.camera_.roll(r * roll_speed * effective_dt);
                renderer.reset_accumulation();
            }
        }
    );

    window.register_key(
        {SDL_SCANCODE_O}, Window::Trigger::ANY_JUST_PRESSED, [&](const Window::KeyState&, float) {
            if (!world.camera_.is_orbiting_) {
                world.camera_.start_orbiting();
            } else {
                world.camera_.stop_orbiting();
            }
            renderer.reset_accumulation();
        }
    );

    window.register_key(
        {SDL_SCANCODE_1, SDL_SCANCODE_2, SDL_SCANCODE_3, SDL_SCANCODE_4, SDL_SCANCODE_0},
        Window::Trigger::ANY_JUST_PRESSED,
        [&](const Window::KeyState& ks, float) {
            using enum Renderer::Mode;
            std::string_view mode_name;
            bool switched = false;
            if (ks[SDL_SCANCODE_1]) {
                switched = WIREFRAME != std::exchange(renderer.mode_, WIREFRAME);
                mode_name = "WIREFRAME";
            } else if (ks[SDL_SCANCODE_2]) {
                switched = RASTERIZED != std::exchange(renderer.mode_, RASTERIZED);
                mode_name = "RASTERIZED";
            } else if (ks[SDL_SCANCODE_3]) {
                switched = RAYTRACED != std::exchange(renderer.mode_, RAYTRACED);
                mode_name = "RAYTRACED";
            } else if (ks[SDL_SCANCODE_4]) {
                switched = DEPTH_OF_FIELD != std::exchange(renderer.mode_, DEPTH_OF_FIELD);
                mode_name = "DEPTH_OF_FIELD";
            } else if (ks[SDL_SCANCODE_0]) {
                switched =
                    PHOTON_VISUALIZATION != std::exchange(renderer.mode_, PHOTON_VISUALIZATION);
                mode_name = "PHOTON_VISUALIZATION";
            }
            if (!switched) return;
            renderer.reset_accumulation();
            fps = 0;
            last_print = std::chrono::steady_clock::now();
            std::cout << std::format("[Renderer] Mode set to {}\n", mode_name);
        }
    );

    window.register_key(
        {SDL_SCANCODE_G}, Window::Trigger::ANY_JUST_PRESSED, [&](const Window::KeyState&, float) {
            renderer.gamma_ = (renderer.gamma_ == 2.2f) ? 1.0f : 2.2f;
        }
    );
    window.register_key(
        {SDL_SCANCODE_P}, Window::Trigger::ANY_JUST_PRESSED, [&](const Window::KeyState&, float) {
            if (renderer.is_photon_map_ready()) {
                renderer.caustics_enabled_ = !renderer.caustics_enabled_;
                std::cout << std::format(
                    "[PhotonMap] Caustics Enabled: {}\n", renderer.caustics_enabled_
                );
                renderer.reset_accumulation();
            } else {
                std::cout << "[PhotonMap] Caustics photon map is not ready yet" << std::endl;
            }
        }
    );

    // Aperture control (+/-)
    window.register_key(
        {SDL_SCANCODE_EQUALS, SDL_SCANCODE_MINUS},
        Window::Trigger::ANY_PRESSED_NO_MODIFIER,
        [&](const Window::KeyState& ks, float) {
            constexpr FloatType step = 0.01f;
            FloatType& aperture = renderer.aperture_size_;

            if (ks[SDL_SCANCODE_EQUALS]) aperture += step;
            if (ks[SDL_SCANCODE_MINUS]) aperture -= step;
            aperture = std::clamp(aperture, 0.0f, 2.0f);

            std::cout << std::format("[DepthOfField] Aperture Size: {:.2f}\n", aperture);
            renderer.reset_accumulation();
        }
    );

    // Screenshot save (Ctrl+S)
    window.register_key(
        {SDL_SCANCODE_LCTRL, SDL_SCANCODE_S},
        Window::Trigger::ALL_JUST_PRESSED,
        [&](const Window::KeyState& ks, float) {
            window.save_ppm("screenshot.ppm");
            window.save_bmp("screenshot.bmp");
            std::cout << "[Screenshot] Saved as screenshot.ppm and screenshot.bmp\n";
        }
    );

    // Video recording toggle (Ctrl+R)
    window.register_key(
        {SDL_SCANCODE_LCTRL, SDL_SCANCODE_R},
        Window::Trigger::ALL_JUST_PRESSED,
        [&](const Window::KeyState&, float) { video_recorder.toggle_recording(); }
    );

    // Offline/Realtime render mode toggle (H)
    window.register_key(
        {SDL_SCANCODE_H}, Window::Trigger::ANY_JUST_PRESSED, [&](const Window::KeyState&, float) {
            renderer.offline_render_mode_ = !renderer.offline_render_mode_;
            std::cout << std::format(
                "[Renderer] Render mode: {}\n",
                renderer.offline_render_mode_ ? "OFFLINE (64 samples/frame)"
                                              : "REALTIME (progressive)"
            );
            renderer.reset_accumulation();
        }
    );

    // Normal debug mode toggle (N) - only for raytracing modes
    window.register_key(
        {SDL_SCANCODE_N}, Window::Trigger::ANY_JUST_PRESSED, [&](const Window::KeyState&, float) {
            renderer.normal_debug_mode_ = !renderer.normal_debug_mode_;
            std::cout << std::format(
                "[Renderer] Normal debug mode: {}\n", renderer.normal_debug_mode_
            );
            renderer.reset_accumulation();
        }
    );

    // Mouse look (left button drag)
    window.register_mouse(
        SDL_BUTTON_LEFT, Window::Trigger::ANY_PRESSED, [&](int xrel, int yrel, float dt) {
            if (xrel == 0 && yrel == 0) return;
            constexpr FloatType MOUSE_SENSITIVITY = 0.002f;
            FloatType dx0 = -static_cast<FloatType>(xrel) * MOUSE_SENSITIVITY;
            FloatType dy0 = static_cast<FloatType>(yrel) * MOUSE_SENSITIVITY;
            FloatType roll = world.camera_.roll_;
            FloatType c = std::cos(roll);
            FloatType s = std::sin(roll);
            FloatType d_yaw = dx0 * c + dy0 * s;
            FloatType d_pitch = -dx0 * s + dy0 * c;
            world.camera_.rotate(d_yaw, d_pitch);
            renderer.reset_accumulation();
        }
    );

    // Keyboard look (arrow keys)
    window.register_key(
        {SDL_SCANCODE_UP, SDL_SCANCODE_DOWN, SDL_SCANCODE_LEFT, SDL_SCANCODE_RIGHT},
        Window::Trigger::ANY_PRESSED_NO_MODIFIER,
        [&](const Window::KeyState& ks, float dt) {
            constexpr FloatType ROTATE_SPEED = 0.2f;
            constexpr FloatType video_fixed_dt = 1.0f / 60.0f;  // Fixed step for video recording
            FloatType dx0 =
                (ks[SDL_SCANCODE_RIGHT] ? 1.0f : 0.0f) - (ks[SDL_SCANCODE_LEFT] ? 1.0f : 0.0f);
            FloatType dy0 =
                (ks[SDL_SCANCODE_UP] ? 1.0f : 0.0f) - (ks[SDL_SCANCODE_DOWN] ? 1.0f : 0.0f);
            if (dx0 != 0.0f || dy0 != 0.0f) {
                FloatType roll = world.camera_.roll_;
                FloatType c = std::cos(roll);
                FloatType s = std::sin(roll);
                FloatType effective_dt = video_recorder.is_recording() ? video_fixed_dt : dt;
                FloatType d_yaw = (dx0 * c + dy0 * s) * ROTATE_SPEED * effective_dt;
                FloatType d_pitch = (-dx0 * s + dy0 * c) * ROTATE_SPEED * effective_dt;
                world.camera_.rotate(d_yaw, d_pitch);
                renderer.reset_accumulation();
            }
        }
    );

    // Focal distance control via scroll
    window.register_scroll([&](int y_offset) {
        constexpr FloatType factor = 1.1f;

        FloatType& fd = renderer.focal_distance_;
        fd *= std::pow(factor, static_cast<FloatType>(y_offset));
        fd = std::max(fd, 1.0f);
        std::cout << std::format("[DepthOfField] Focal Distance: {:.2f}\n", fd);
        renderer.reset_accumulation();
    });

    while (true) {
        auto frame_start = std::chrono::steady_clock::now();

        world.camera_.orbiting();
        renderer.render();
        if (video_recorder.is_recording()) video_recorder.capture_frame();

        if (!window.process_events()) break;
        window.update();

        // FPS counter
        fps++;
        auto now = std::chrono::steady_clock::now();
        std::chrono::duration<double> elapsed = now - last_print;
        if (elapsed >= std::chrono::seconds(1)) {
            std::cout << std::format(
                "[Renderer] FPS: {:#.3g} | Avg Frame Time: {:#.4g} ms\n",
                static_cast<double>(fps) / elapsed.count(),
                std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count() /
                    static_cast<double>(fps)
            );
            fps = 0;
            last_print = now;
        }

        // Soft frame rate limit for video recording mode (target ~60fps)
        if (video_recorder.is_recording()) {
            auto frame_end = std::chrono::steady_clock::now();
            auto frame_duration =
                std::chrono::duration_cast<std::chrono::microseconds>(frame_end - frame_start);
            // Target 60fps (16.67ms), but use slightly shorter sleep to stay above 60fps
            constexpr auto target_frame_time = std::chrono::microseconds(15000);
            if (frame_duration < target_frame_time) {
                std::this_thread::sleep_for(target_frame_time - frame_duration);
            }
        }
    }
}
